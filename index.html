<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Generative Evolving Clouds with Fixed Grow/Dissipate Regions & Modified Threshold</title>
  <style>
    body { margin: 0; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="glCanvas"></canvas>
  
  <!-- Vertex Shader: Passes through vertex positions -->
  <script id="vertexShader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    void main() {
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  </script>
  
  <!-- Fragment Shader: Generates evolving clouds with fixed grow/dissipate regions -->
  <script id="fragmentShader" type="x-shader/x-fragment">
    precision highp float;
    
    uniform vec2 u_resolution;
    uniform float u_time;
    
    // Uniforms for randomized parameters.
    uniform float u_seed;
    uniform float u_motionSpeed;
    uniform vec2 u_motionDirection;
    uniform float u_cloudDensity;
    
    // Hash function modified with u_seed.
    float hash(vec2 p) {
      return fract(sin(dot(p + vec2(u_seed), vec2(127.1, 311.7))) * 43758.5453123);
    }
    
    // 2D value noise.
    float noise(vec2 p) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      
      float a = hash(i);
      float b = hash(i + vec2(1.0, 0.0));
      float c = hash(i + vec2(0.0, 1.0));
      float d = hash(i + vec2(1.0, 1.0));
      
      vec2 u = f * f * (3.0 - 2.0 * f);
      return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
    }
    
    // Fractal Brownian Motion (fbm) with 5 octaves.
    float fbm(vec2 p) {
      float value = 0.0;
      float amplitude = 0.5;
      for (int i = 0; i < 5; i++) {
        value += amplitude * noise(p);
        p *= 2.0;
        amplitude *= 0.5;
      }
      return value;
    }
    
    void main() {
      // Normalize pixel coordinates (0.0 to 1.0).
      vec2 uv = gl_FragCoord.xy / u_resolution;
      
      // Scale and pan for cloud details.
      float zoom = 3.0;
      vec2 pos = uv * zoom;
      
      // Animate clouds with variable motion speed and direction.
      pos += u_time * u_motionSpeed * u_motionDirection;
      
      // Add turbulence for natural evolution.
      pos += vec2(0.05 * sin(u_time * 0.3), 0.05 * cos(u_time * 0.3));
      
      // Base cloud density from fbm.
      float n = fbm(pos);
      
      // --- Enhanced Depth Layer ---
      // Compute an additional noise value to simulate cloud thickness/depth.
      float depthNoise = fbm(pos * 0.7 + 10.0);
      depthNoise = pow(depthNoise, 1.5);  // sharpen contrast
      
      // --- Fixed Evolution Type ---
      // Use a low-frequency noise to assign each area an evolution type:
      // evolveType = 1.0 means this region will only grow (clouds get thicker);
      // evolveType = 0.0 means this region will only dissipate (clouds thin out).
      float evolveType = step(0.5, noise(pos * 0.1 + vec2(10.0, 20.0)));
      
      // Vary the local growth/dissipation rate using another low-frequency noise.
      float baseRate = noise(pos * 0.05 + vec2(5.0));
      float growthRate = 0.05 + 0.05 * baseRate;  // varies between about 0.05 and 0.1
      
      // Compute local evolution monotonically.
      // Regions with evolveType==1 will increase from 0.5 upward,
      // while regions with evolveType==0 will decrease from 0.5 downward.
      float localEvolve = clamp(0.5 + (evolveType * 2.0 - 1.0) * u_time * growthRate, 0.0, 1.0);
      
      // Adjust the cloud formation threshold:
      // Base threshold now varies between 0.25 and 0.75,
      // and depth noise is multiplied by 0.7.
      float threshold = mix(0.25, 0.75, localEvolve) - u_cloudDensity * 0.1 - (depthNoise * 0.7);
      float cloudMask = smoothstep(threshold, threshold + 0.1, n);
      
      // --- Varying Cloud Color Based on Depth ---
      // Blend between a light, wispy cloud and a darker, denser cloud tone.
      vec3 lightCloud = vec3(1.0);
      vec3 deepCloud = vec3(0.6, 0.6, 0.7);
      vec3 cloudColor = mix(lightCloud, deepCloud, depthNoise);
      vec3 skyColor = vec3(0.6, 0.8, 0.95); // light blue sky
      
      // Final color: blend cloud and sky based on the cloud mask.
      vec3 color = mix(cloudColor, skyColor, cloudMask);
      
      gl_FragColor = vec4(color, 1.0);
    }
  </script>
  
  <!-- JavaScript: Initializes WebGL, compiles shaders, and renders the scene with randomized parameters -->
  <script>
    (function(){
      const canvas = document.getElementById("glCanvas");
      const gl = canvas.getContext("webgl");
      if (!gl) {
        alert("WebGL not supported");
        return;
      }
      
      // Resize canvas to fill the window.
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      
      // Helper: compile shader.
      function compileShader(source, type) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error("Shader compile error:", gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }
      
      const vertexSource = document.getElementById("vertexShader").text;
      const fragmentSource = document.getElementById("fragmentShader").text;
      
      const vertexShader = compileShader(vertexSource, gl.VERTEX_SHADER);
      const fragmentShader = compileShader(fragmentSource, gl.FRAGMENT_SHADER);
      
      // Link shaders into a program.
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error("Program linking error:", gl.getProgramInfoLog(program));
        return;
      }
      gl.useProgram(program);
      
      // Create a full-screen quad (two triangles).
      const vertices = new Float32Array([
        -1, -1,
         1, -1,
        -1,  1,
        -1,  1,
         1, -1,
         1,  1
      ]);
      const vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
      
      const a_position = gl.getAttribLocation(program, "a_position");
      gl.enableVertexAttribArray(a_position);
      gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
      
      // Uniform locations.
      const u_resolution = gl.getUniformLocation(program, "u_resolution");
      const u_time = gl.getUniformLocation(program, "u_time");
      const u_seed = gl.getUniformLocation(program, "u_seed");
      const u_motionSpeed = gl.getUniformLocation(program, "u_motionSpeed");
      const u_motionDirection = gl.getUniformLocation(program, "u_motionDirection");
      const u_cloudDensity = gl.getUniformLocation(program, "u_cloudDensity");
      
      // Generate random values.
      const seedVal = Math.random() * 1000.0;
      const motionSpeedVal = 0.02 + Math.random() * 0.08; // between 0.02 and 0.1
      const angle = Math.random() * Math.PI * 2.0;
      const motionDirectionVal = [Math.cos(angle), Math.sin(angle)];
      const cloudDensityVal = Math.random() * 2.0 - 1.0; // range: [-1, 1]
      
      // Set uniform values.
      gl.uniform1f(u_seed, seedVal);
      gl.uniform1f(u_motionSpeed, motionSpeedVal);
      gl.uniform2fv(u_motionDirection, motionDirectionVal);
      gl.uniform1f(u_cloudDensity, cloudDensityVal);
      
      // Render loop.
      function render(time) {
        time *= 0.001; // convert to seconds
        gl.uniform2f(u_resolution, canvas.width, canvas.height);
        gl.uniform1f(u_time, time);
        
        gl.clearColor(0.6, 0.8, 0.95, 1.0); // clear to sky color
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
    })();
  </script>
</body>
</html>
